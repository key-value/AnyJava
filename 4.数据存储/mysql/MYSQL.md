# 数据库
## 数据类型
 * char varchar nvarchar 数据结构
## 数据隔离
## 索引
### 1、哈希索引
哈希索引（hash index）基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（hash code），哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。
### 2、最左原则

## 读写分离
主库将变更写入 binlog 日志，然后从库连接到主库之后，从库有一个 IO 线程，将主库的 binlog 日志拷贝到自己本地，写入一个 relay 中继日志中。接着从库中有一个 SQL 线程会从中继日志读取 binlog，然后执行 binlog 日志中的内容，也就是在自己本地再次执行一遍 SQL，这样就可以保证自己跟主库的数据是一样的。

1.  **「同步策略」**：Master会等待所有的Slave都回应后才会提交，这个主从的同步的性能会严重的影响。
2.  **「半同步策略」**：Master至少会等待一个Slave回应后提交。
3.  **「异步策略」**：Master不用等待Slave回应就可以提交。
4.  **「延迟策略」**：Slave要落后于Master指定的时间。



* 如何提高读写分离的效率

我们通过 MySQL 命令：  

```text
show status
```

查看 `Seconds_Behind_Master`，可以看到从库复制主库的数据落后了几 ms。

一般来说，如果主从延迟较为严重，有以下解决方案：

1.  我们知道因为主服务器要负责更新操作， 它对安全性的要求比从服务器高，所有有些设置可以修改，比如sync_binlog=1，innodb_flush_log_at_trx_commit = 1 之类的设置，而 slave 则不需要这么高的数据安全，完全可以将 sync_binlog 设置为 0 或者关闭 binlog、innodb_flushlog、innodb_flush_log_at_trx_commit 也 可以设置为 0 来提高 SQL 的执行效率。[sync_binlog=1，innodb_flush_log_at_trx_commit = 1](https://www.cnblogs.com/klvchen/p/10861850.html)
	-   如果启用了二进制日志，则设置sync_binlog=1，即每提交一次事务同步二进制文件写到磁盘中。
-   总是设置innodb_flush_log_at_trx_commit=1，即每提交一次事务redo log都写到磁盘中。
2. 打开 MySQL 支持的并行复制，多个库并行复制。如果说某个库的写入并发就是特别高，单库写并发达到了 2000/s，并行复制还是没意义。
-   如果确实是存在必须先插入，立马要求就查询到，然后立马就要反过来执行一些操作，对这个查询**设置直连主库**。**不推荐**这种方法，你这么搞导致读写分离的意义就丧失了。

MySQL 5.6版本以后通过并行复制的方式来解决 SQL 单线程产生的主从延迟问题。对于低版本来说，可以通过降低主库的并发来解决。如果对数据实时性要求比较严格的话，可以通过读主库来达到目的。