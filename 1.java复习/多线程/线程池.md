-   **使用线程池的好处**

1、降低资源消耗：通过重复利用已创建的线程降低线程创建和销毁造成的消耗;

2、 提高响应速度：当任务到达时，任务可以不需要的等到线程创建就能立即执行;

3、 提高线程的可管理性：线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。

# 执行 execute() 方法和 submit() 方法的区别是什么呢？

1、 execute() 方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；

2、 submit() 方法用于提交需要返回值的任务。线程池会返回一个 Future 类型的对象，通过这个 Future 对象可以判断任务是否执行成功，并且可以通过 Future 的 get() 方法来获取返回值，get() 方法会阻塞当前线程直到任务完成，而使用 get(long timeout，TimeUnit unit) 方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。


## shutdown()

-   不能接受新的**submit**
-   并没有任何的**interrupt**操作，会等待线程池中所有线程（执行中的以及排队的）执行完毕


_可以理解为是个标识性质的方法，标识这程序有意愿在此刻终止线程池的后续操作。
shutdown方法调用后，就不能再继续使用ExecutorService来追加新的任务了，如果继续调用execute方法执行新的任务的话就会抛出RejectedExecutionException异常。(submit方法也会抛出上述异常)

## shutdownNow()

-   **会尝试interrupt**线程池中正在执行的线程
-   等待执行的线程也会被取消
-   但是**并不能保证一定能**成功的interrupt线程池中的线程。
-   会返回并未终止的线程列表`List<Runnable>`

_shutdownNow()方法比shutdown()强硬了很多，不仅取消了排队的线程而且确实尝试终止当前正在执行的线程。_

## awaitTermination(n, TimeUnit)

-   该方法返回值为boolean类型
-   方法的两个参数规定了方法的阻塞时间，在**阻塞时间内**除非所有线程**都执行完毕**才会提前返回`true`
-   如果到了规定的时间，线程池中的线程并没有全部结束返回false
-   InterruptedException 这个异常也会导致方法的终止

利用这个阻塞方法的特性，我们可以优雅的关闭线程池中的任务。

正确的调用顺序是

shutdown方法  
awaitTermination方法  
shutdownNow方法(发生异常或者是Timeout的时候)