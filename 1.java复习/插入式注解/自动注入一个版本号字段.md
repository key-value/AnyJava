有没有更好的解决办法呢？比如我们可不可以在gradle打包构建时拿到jar包的版本号，然后注入到每个组件中去呢？就像lombok那样，不需要写get、set方法，只需要加个注解标记就可以自动注入get、set方法。

比如我们可以给每个组件定义一个空常量，加上自定义的注解：

`@TrisceliVersion   public static final String version = "";   `

然后像lombok生成set/get方法那样注入真正的版本号：

`@TrisceliVersion   public static final String version = "1.0.31-SNAPSHOT";   `

参考lombok的实现，这其实是可以做到的，下面来看解决方案。

##   

## **解决**

java中解析一个注解的方式主要有两种：编译期扫描、运行期反射，这是lombok `@Setter`的实现：

`@Target({ElementType.FIELD, ElementType.TYPE})   @Retention(RetentionPolicy.SOURCE)   public @interface Setter {      // 略...   }   `

可以看到`@Setter`的`Retention`是`SOURCE`类型的，也就是说这个注解只在编译期有效，它甚至不会被编入class文件，所以lombok无疑是第一种解析方式，那用什么方式可以在编译期就让注解被解析到并执行我们的解析代码呢？答案就是定义插入式注解处理器（通过JSR-269提案定义的`Pluggable Annotation Processing API`实现）

插入式注解处理器的触发点如下图所示：

![图片](https://mmbiz.qpic.cn/sz_mmbiz_jpg/knmrNHnmCLEibXby2z9xbG90150tLh8SXvrqFbwTfy998MGzf082KicCJU6WJnblQnrIrhEoDIx4Yjzq1bAnjeyw/640?wx_fmt=other&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

  

也就是说插入式注解处理器可以帮助我们在编译期修改抽象语法树（AST）！所以现在我们只需要自定义一个这样的处理器，然后其内部拿到jar版本信息（因为是编译期，可以找到源码的path，源码里随便搞个文件存放版本号，然后用java io读取进来即可），再将注解对应语法树上的常量值设置成jar包版本号，语法树变了，最终生成的字节码也会跟着变，这样就实现了我们想在编译期给常量version注入值的愿望。

自定义一个插入式注解处理器也很简单，首先要将自己的注解定义出来：

`@Documented   @Retention(RetentionPolicy.SOURCE) //只在编译期有效，最终不会打进class文件中   @Target({ElementType.FIELD}) //仅允许作用于类属性之上   public @interface TrisceliVersion {   }   `

然后定义一个继承了`AbstractProcessor`的处理器：

`/**    * {@link AbstractProcessor} 就属于 Pluggable Annotation Processing API    */   public class TrisceliVersionProcessor extends AbstractProcessor {          private JavacTrees javacTrees;       private TreeMaker treeMaker;       private ProcessingEnvironment processingEnv;          /**        * 初始化处理器        *        * @param processingEnv 提供了一系列的实用工具        */       @SneakyThrows       @Override       public synchronized void init(ProcessingEnvironment processingEnv) {           super.init(processingEnv);           this.processingEnv = processingEnv;           this.javacTrees = JavacTrees.instance(processingEnv);           Context context = ((JavacProcessingEnvironment) processingEnv).getContext();           this.treeMaker = TreeMaker.instance(context);       }             @Override       public SourceVersion getSupportedSourceVersion() {           return SourceVersion.latest();       }          @Override       public Set<String> getSupportedAnnotationTypes() {           HashSet<String> set = new HashSet<>();           set.add(TrisceliVersion.class.getName()); // 支持解析的注解           return set;       }          @Override       public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {           for (TypeElement t : annotations) {               for (Element e : roundEnv.getElementsAnnotatedWith(t)) { // 获取到给定注解的element（element可以是一个类、方法、包等）                   // JCVariableDecl为字段/变量定义语法树节点                   JCTree.JCVariableDecl jcv = (JCTree.JCVariableDecl) javacTrees.getTree(e);                   String varType = jcv.vartype.type.toString();                   if (!"java.lang.String".equals(varType)) { // 限定变量类型必须是String类型，否则抛异常                       printErrorMessage(e, "Type '" + varType + "'" + " is not support.");                   }                   jcv.init = treeMaker.Literal(getVersion()); // 给这个字段赋值，也就是getVersion的返回值               }           }           return true;       }          /**        * 利用processingEnv内的Messager对象输出一些日志        *        * @param e element        * @param m error message        */       private void printErrorMessage(Element e, String m) {           processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, m, e);       }          private String getVersion() {           /**            * 获取version，这里省略掉复杂的代码，直接返回固定值            */           return "v1.0.1";       }   `

定义好的处理器需要`SPI机制`被发现，所以需要定义`META.services`：

![图片](https://mmbiz.qpic.cn/sz_mmbiz_jpg/knmrNHnmCLEibXby2z9xbG90150tLh8SXI3DG7Xnk4pu44xeE00aTsbsCrWhuiaMNxMt4zSR8J0VDG7RxzrY2ibGw/640?wx_fmt=other&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)