1、信号量 s 是一个确定的二元组 (value，list)，其中 value 为整型变量，代表某一种资源的数量，系统初始化为期赋值；list 是等待使用此类资源的进程队列的头指针，初始状态为空队列。

2、除了赋初值之外，信号量仅能有同步原语 P 和 V 对其进行操作 (原语是指定完成某种功能且不被分割不被终端执行的操作序列).

3、P (s)：将信号量 value 值减 1，若结果小于 0，则执行 P 操作的线程被阻塞，插入与 s 信号量相关的 list 所指向的队列中，若结果大于等于 0，则执行 p 操作的线程继续执行。

4、V (s)：将信号量 value 值加 1，若结果不大于 0，（说明还有线程在等待该资源）则执行 V 操作的线程从信号量有关的 list 所指队列中释放一个进程，使其转换为就绪，自己则继续执行；若结果大于 0，则执行 V 操作的进程继续执行。

从信号量和 PV 操作的定义可获得如下推论
推论 1：若信号量 s.value 为正值，vaule 的值即 s 所代表的资源的可用数量。
推论 2：若信号量 s.value 为负值，value 的绝对值等于登记在 s 信号量队列 list 中等待的线程个数。
推论 3：P 操作通常意味着请求一个资源，V 操作意味着释放一个资源，在一定的条件下，P 操作代表刮起线程的操作，而 V 操作代表唤醒被挂起线程的操作。



>typeof struct semaphore{
> int value;//信号量值 
> struct pcb *list;//信号量队列指针
>  }


synchronized 代码块实际上多了 monitorenter 和 monitorexit 两条指令


# CountDownLatch 和 CyclicBarrier 有什么区别？

CountDownLatch 是计数器，只能使用一次，而 CyclicBarrier 的计数器提供 reset 功能，可以多次使用。

CountDownLatch 是计数器，线程完成一个记录一个，只不过计数不是递增而是递减，而 CyclicBarrier 更像是一个阀门，需要所有线程都到达，阀门才能打开，然后继续执行。